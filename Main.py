import argparse
from pathlib import Path

from source import Prepare
from source import BlastTools
from source import Verify
from source import  Iteration
from source import Merge

from Bio import SeqIO


root_dir = Path.cwd()
data_dir = root_dir.joinpath('data')
db_dir = root_dir.joinpath('db')
result_dir = root_dir.joinpath('result')

# specify dependecncy path
Verify.KAKS_PATH = root_dir.joinpath('package', 'KaKs_Calculator2.0', 'bin')
Verify.MAFFT_PATH = root_dir.joinpath('package', 'mafft-linux64')
Prepare.BLAST_PATH  = root_dir.joinpath('package', 'ncbi-blast-2.11.0+', 'bin')
BlastTools.BLAST_PATH = root_dir.joinpath('package', 'ncbi-blast-2.11.0+', 'bin')


def handle_db(DATABASE):
    db_path = Path(DATABASE).resolve()
    if db_path.is_file():
        # build blastdb from user specified fasta file
        Prepare.build_db(DATABASE, str(db_dir.joinpath(db_path.stem)))
        return str(db_dir.joinpath(db_path.stem))
    else:
        # parse existed blastdb name
        return str(db_dir.joinpath(DATABASE))


def handle_mask(NEGATIVE_SEQIDLIST):
    mask_path = Path(NEGATIVE_SEQIDLIST).resolve()
    if mask_path.suffix == '.acc':
        # parse binary file path
        return str(mask_path)
    elif mask_path.suffix == '.id':
        # covert txt file to binary file
        out_mask_path = mask_path.with_suffix('.acc')
        Prepare.convert_to_binary(NEGATIVE_SEQIDLIST, out_mask_path)
        return str(out_mask_path)
    else:
        raise ValueError('negative_seqidlist file must with ".id" as suffix')


def handle_backbone(BACKBONE, DATABASE, NEGATIVE_SEQIDLIST):
    if BACKBONE:
        # read user specify sequences
        return SeqIO.read(BACKBONE, 'fasta')
    else:
        # auto choose the cloest sequence as backbone
        backbone = BlastTools.get_gene_backbone(QUERY, DATABASE, NEGATIVE_SEQIDLIST)
    return backbone


def handle_output(OUTPUT, PLOT):
    log_path = result_dir / (OUTPUT + ".log")
    if PLOT:
        fig_path = result_dir / (PLOT + ".png")
        return str(fig_path), str(fig_path)
    else:
        return str(log_path), False


parser = argparse.ArgumentParser(description="Pipline for identifying recombination event with the consideration of convergent evolution.")
# file parameters
parser.add_argument('--query', '-q', help='Required, query file path, fasta format', required=True)
parser.add_argument('--backbone', '-b', help='Optional, backbone file path, fasta format, if not given, auto-select the sequence closest to the query', required=False, default=False)
parser.add_argument('--negative_seqidlist', '-n', help='Required, negative sequence id file (with ".id" as suffix), which was used to exclude sequences in the same clade with query', required=True)
parser.add_argument('--database', '-db', help='Required, fasta file path, or Database name (in "db" folder) generated by makeblastdb', required=True)
parser.add_argument('--output', '-o', help='Required, name of log file, auto-saved in "result" folder', required=False, default='log')
parser.add_argument('--plot', '-p', help='Optional, name of result figure, auto-saved in result folder. Alternatively one can plot the result from the log file and ignore this option', required=False, default=False)
# programme parameters
parser.add_argument('--window_size', '-ws', help='Optional, window size, default 501', required=False, default=501, type=int)
parser.add_argument('--step', '-s', help='Optional, step size, default 3, must be an integer multiple of 3', required=False, default=3, type=int)
parser.add_argument('--num_cpus', '-nc', help='Optional, number of CPUs, default 4', required=False, default=4, type=int)
# result parameters
parser.add_argument('--min_length', '-l', help='Optional, minimum length of each recombinant region', required=False, default=200, type=int)
parser.add_argument('--bootstrap_threshold', '-bs', help='Optional, bootstrap threshold', required=False, default=0.8, type=float)

args = parser.parse_args()

QUERY = SeqIO.read(args.query, 'fasta')

NEGATIVE_SEQIDLIST = handle_mask(args.negative_seqidlist)
DATABASE = handle_db(args.database)
BACKBONE = handle_backbone(args.backbone, DATABASE, NEGATIVE_SEQIDLIST)
OUTPUT, PLOT = handle_output(args.output, args.plot)


WINDOW_SIZA = args.window_size
STEP = args.step
NUM_CPUs = args.num_cpus

MIN_LENGTH = args.min_length
BOOTSTRAP_THRESHOLD = args.bootstrap_threshold

Iteration.main(OUTPUT, QUERY, BACKBONE, DATABASE, NEGATIVE_SEQIDLIST, NUM_CPUs, WINDOW_SIZA, STEP)
if PLOT:
    gap_window = round(MIN_LENGTH / STEP)
    Merge.parse_log(OUTPUT, STEP, gap_window, BOOTSTRAP_THRESHOLD, plot=PLOT)
